// Code generated by jk generate all -t Service; DO NOT EDIT.

package stringsvc

import (
	"bytes"
	"context"
	"embed"
	"encoding/json"
	"github.com/go-kit/kit/endpoint"
	"github.com/juju/errors"
	httprouter "github.com/julienschmidt/httprouter"
	httpSwagger "github.com/swaggo/http-swagger/v2"
	"net/http"
	"net/url"
)

func makeHandlerFunc[REQ any, RESP any](f func(context.Context, REQ) (RESP, error)) http.HandlerFunc {
	return func(wr http.ResponseWriter, request *http.Request) {
		var payload REQ
		err := json.NewDecoder(request.Body).Decode(&payload)
		if err != nil {
			panic(errors.Errorf("unexpected unmarshal error %+v", err))
		}

		resp, err := f(request.Context(), payload)
		err = json.NewEncoder(wr).Encode(resp)
		if err != nil {
			panic(errors.Errorf("unexpected unmarshal error %+v", err))
		}
	}
}

func makeRemoteEndpoint[REQ any, RESP any](remoteUrl string, client *http.Client) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		buffer := bytes.NewBufferString("")
		err := json.NewEncoder(buffer).Encode(req)
		if err != nil {
			panic(errors.Errorf("unexpected marshal error %+v", err))
		}

		request, err := http.NewRequestWithContext(ctx, http.MethodPost, remoteUrl, buffer)
		if err != nil {
			return nil, errors.Trace(err)
		}

		response, err := client.Do(request)
		if err != nil {
			return nil, errors.Trace(err)
		}

		defer response.Body.Close()
		if response.StatusCode != http.StatusOK {
			return nil, errors.Errorf("call remote endpoint failed, http status %d %s", response.StatusCode, response.Status)
		}

		var resp RESP
		err = json.NewDecoder(response.Body).Decode(&resp)
		if err != nil {
			return nil, errors.Trace(err)
		}

		return resp, nil
	}
}

func NewClient(host string, client *http.Client) Service {
	urlBuy := url.URL{
		Host:   host,
		Path:   "/api/v1/service/buy",
		Scheme: "https",
	}
	urlJoin := url.URL{
		Host:   host,
		Path:   "/api/v1/service/join",
		Scheme: "https",
	}
	urlJoin2 := url.URL{
		Host:   host,
		Path:   "/api/v1/service/join-2",
		Scheme: "https",
	}
	urlJoin3 := url.URL{
		Host:   host,
		Path:   "/api/v1/service/join-3",
		Scheme: "https",
	}
	urlLowercase := url.URL{
		Host:   host,
		Path:   "/api/v1/service/lowercase",
		Scheme: "https",
	}
	urlUppercase := url.URL{
		Host:   host,
		Path:   "/api/v1/service/uppercase",
		Scheme: "https",
	}
	return EndpointSet{
		BuyEndpoint:       makeRemoteEndpoint[BuyRequest, BuyResponse](urlBuy.String(), client),
		Join2Endpoint:     makeRemoteEndpoint[Join2Request, Join2Response](urlJoin2.String(), client),
		Join3Endpoint:     makeRemoteEndpoint[Join3Request, Join3Response](urlJoin3.String(), client),
		JoinEndpoint:      makeRemoteEndpoint[JoinRequest, JoinResponse](urlJoin.String(), client),
		LowercaseEndpoint: makeRemoteEndpoint[LowercaseRequest, LowercaseResponse](urlLowercase.String(), client),
		UppercaseEndpoint: makeRemoteEndpoint[UppercaseRequest, UppercaseResponse](urlUppercase.String(), client),
	}
}

//go:embed swagger.json
var swagger embed.FS

func Register(svc Service, m *httprouter.Router) {
	m.Handler(http.MethodGet, "/swagger/service/spec/*rest", http.StripPrefix("/swagger/service/spec/", http.FileServer(http.FS(swagger))))
	m.Handler(http.MethodGet, "/swagger/service/swagger-ui/*rest", httpSwagger.Handler(httpSwagger.URL("/swagger/service/spec/swagger.json")))
	m.Handler(http.MethodPost, "/api/v1/service/buy", makeHandlerFunc(svc.Buy))
	m.Handler(http.MethodPost, "/api/v1/service/join", makeHandlerFunc(svc.Join))
	m.Handler(http.MethodPost, "/api/v1/service/join-2", makeHandlerFunc(svc.Join2))
	m.Handler(http.MethodPost, "/api/v1/service/join-3", makeHandlerFunc(svc.Join3))
	m.Handler(http.MethodPost, "/api/v1/service/lowercase", makeHandlerFunc(svc.Lowercase))
	m.Handler(http.MethodPost, "/api/v1/service/uppercase", makeHandlerFunc(svc.Uppercase))
}
