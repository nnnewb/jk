package main

import (
	"fmt"
	"github.com/dave/jennifer/jen"
	"github.com/nnnewb/jk/internal/gen"
	"github.com/pkg/errors"
	"github.com/spf13/pflag"
	"go/importer"
	"go/token"
	"go/types"
	"golang.org/x/mod/modfile"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
)

var cliArgs = struct {
	Package  string
	TypeName string
}{}

func init() {
	pflag.StringVarP(&cliArgs.Package, "package", "p", "", "package name of given type")
	pflag.StringVarP(&cliArgs.TypeName, "type", "t", "", "type name of service interface")
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	pflag.Parse()
	if cliArgs.TypeName == "" {
		log.Fatalf("typename not specified")
	}

	if cliArgs.Package == "" {
		wd, err := os.Getwd()
		if err != nil {
			log.Fatalf("get working directory failed, error %+v", err)
		}
		p, err := resolveFullPackagePath(wd, wd)
		if err != nil {
			log.Fatalf("can not resolve full path of current working directory %s, error %+v", wd, err)
		}

		cliArgs.Package = p
	}

	fset := token.NewFileSet()
	imp := importer.ForCompiler(fset, "source", nil)
	pkg, err := imp.Import(cliArgs.Package)
	if err != nil {
		log.Fatalf("import package %s failed, error %+v", cliArgs.Package, err)
	}

	result := pkg.Scope().Lookup(cliArgs.TypeName)
	if result == nil {
		log.Fatalf("type %s not found in package %s", cliArgs.TypeName, cliArgs.Package)
	}

	f := jen.NewFilePath(result.Pkg().Path())
	f.HeaderComment(fmt.Sprintf("Code generated by jk %s; DO NOT EDIT.", strings.Join(os.Args[1:], " ")))
	err = gen.GenerateEndpoints(f, result.Type().(*types.Named))
	if err != nil {
		log.Fatalf("generate endpoint factory for service failed, error %+v", err)
	}

	err = f.Save("endpoint_gen.go")
	if err != nil {
		log.Fatalf("render generated code failed, error %+v", err)
	}
}

// resolveFullPackagePath 从给定路径向上搜索go模块根目录，返回完整包名
func resolveFullPackagePath(origin, dirpath string) (string, error) {
	filename := filepath.Join(dirpath, "go.mod")
	if _, err := os.Stat(filename); err == nil {
		content, err := os.ReadFile(filename)
		if err != nil {
			return "", errors.WithStack(err)
		}
		file, err := modfile.Parse(filename, content, nil)
		if err != nil {
			return "", errors.WithStack(err)
		}

		relativePath, err := filepath.Rel(dirpath, origin)
		if err != nil {
			return "", errors.WithStack(err)
		}

		return path.Join(file.Module.Mod.Path, strings.ReplaceAll(relativePath, "\\", "/")), nil
	} else {
		dirpath = filepath.Dir(dirpath)
		return resolveFullPackagePath(origin, dirpath)
	}
}
