package grpc

import (
	"fmt"
	"go/types"
	"strconv"

	"github.com/dave/jennifer/jen"
	"github.com/nnnewb/jk/pkg/generator/driver"
	"github.com/nnnewb/jk/pkg/generator/utils"
)

func init() {
	driver.RegisterTransportGenDriver("grpc", GRPCTransportGenerator{})
}

type GRPCTransportGenerator struct {
	req *driver.GenerateRequest
}

func (g GRPCTransportGenerator) GenerateTransport(req *driver.GenerateRequest) error {
	g.req = req
	err := g.generateProto(req)
	if err != nil {
		return err
	}

	err = g.generateEncoder(req)
	if err != nil {
		return err
	}

	return nil
}

func (g GRPCTransportGenerator) generateProto(req *driver.GenerateRequest) error {
	gf := req.GenFile("transport/grpc/rpc.proto")
	gf.P("// This file is generated jk, DO NOT EDIT.\n")
	gf.P("syntax = \"proto3\";\n")
	gf.P("option go_package=\"", req.Pkg.Path(), "\";\n")

	// parameter types may depending on other types, we need define thoese types in Protocol Buffer for serialization
	messages := make(map[string]string)

	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		methodType := method.Type().(*types.Signature)

		gf.P("message ", methodName, "Request {\n")
		for i := 1; i < methodType.Params().Len(); i++ {
			param := methodType.Params().At(i)
			gf.P("    ", typeToProto(param.Type()), " ", param.Name(), " = ", strconv.FormatInt(int64(i), 10), ";\n")
			namedTypeToProtoMessage(param.Type(), messages)
		}
		gf.P("}\n\n")

		gf.P("message ", methodName, "Response {\n")
		for i := 0; i < methodType.Results().Len()-1; i++ {
			result := methodType.Results().At(i)
			gf.P("    ", typeToProto(result.Type()), " ", result.Name(), " = ", strconv.FormatInt(int64(i+1), 10), ";\n")
			namedTypeToProtoMessage(result.Type(), messages)
		}
		gf.P("}\n\n")
	}

	for _, message := range messages {
		gf.P(message)
	}

	gf.P("service ", req.SvcName, " {\n")
	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		// methodType := method.Type().(*types.Signature)

		gf.P("    rpc ", methodName, "(", methodName, "Request) returns (", methodName, "Response);\n")
	}
	gf.P("}\n")

	return nil
}

func (g GRPCTransportGenerator) generateEncoder(req *driver.GenerateRequest) error {
	gf := req.GenFile("transport/grpc/encode.go")
	f := jen.NewFile("grpc")
	f.HeaderComment("This file is generated by jk, DO NOT EDIT.")

	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		// methodType := method.Type().(*types.Signature)

		f.Func().Id(fmt.Sprintf("Encode%sRequest", methodName)).Params(jen.Id("req").Qual(req.Pkg.Path(), fmt.Sprintf("%sRequest", methodName))).Params(jen.Interface(), jen.Error()).Block()
	}

	return f.Render(gf.Writer)
}
