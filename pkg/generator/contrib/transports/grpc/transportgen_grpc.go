package grpc

import (
	"fmt"
	"go/types"
	"strconv"

	"github.com/dave/jennifer/jen"
	"github.com/nnnewb/jk/pkg/generator/driver"
	"github.com/nnnewb/jk/pkg/generator/utils"
)

func init() {
	driver.RegisterTransportGenDriver("grpc", GRPCTransportGenerator{})
}

type GRPCTransportGenerator struct {
	req *driver.GenerateRequest
}

func (g GRPCTransportGenerator) GenerateTransport(req *driver.GenerateRequest) error {
	g.req = req
	err := g.generateProto(req)
	if err != nil {
		return err
	}

	err = g.generateEncoder(req)
	if err != nil {
		return err
	}

	err = g.generateGoGen(req)
	if err != nil {
		return err
	}

	return nil
}

func (g GRPCTransportGenerator) generateProto(req *driver.GenerateRequest) error {
	gf := req.GenFile("transport/grpc/rpc.proto")
	gf.P("// This file is generated jk, DO NOT EDIT.\n")
	gf.P("syntax = \"proto3\";\n")
	gf.P("option go_package=\"", req.Pkg.Path(), "/transport/grpc\";\n")

	// parameter types may depending on other types, we need define thoese types in Protocol Buffer for serialization
	messages := make(map[string]string)

	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		methodType := method.Type().(*types.Signature)

		gf.P("message ", methodName, "Request {\n")
		for i := 1; i < methodType.Params().Len(); i++ {
			param := methodType.Params().At(i)
			gf.P("    ", typeToProto(param.Type()), " ", param.Name(), " = ", strconv.FormatInt(int64(i), 10), ";\n")
			namedTypeToProtoMessage(param.Type(), messages)
		}
		gf.P("}\n\n")

		gf.P("message ", methodName, "Response {\n")
		for i := 0; i < methodType.Results().Len()-1; i++ {
			result := methodType.Results().At(i)
			gf.P("    ", typeToProto(result.Type()), " ", result.Name(), " = ", strconv.FormatInt(int64(i+1), 10), ";\n")
			namedTypeToProtoMessage(result.Type(), messages)
		}
		gf.P("}\n\n")
	}

	for _, message := range messages {
		gf.P(message)
	}

	gf.P("service ", req.SvcName, " {\n")
	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		// methodType := method.Type().(*types.Signature)

		gf.P("    rpc ", methodName, "(", methodName, "Request) returns (", methodName, "Response);\n")
	}
	gf.P("}\n")

	return nil
}

func (g GRPCTransportGenerator) generateEncoder(req *driver.GenerateRequest) error {
	gf := req.GenFile("transport/grpc/encode.go")
	f := jen.NewFile("grpc")
	f.HeaderComment("This file is generated by jk, DO NOT EDIT.")

	epPkg := req.Pkg.Path() + "/endpoint"

	for i := 0; i < req.Svc.NumMethods(); i++ {
		method := req.Svc.Method(i)
		if !method.Exported() {
			continue
		}
		if !utils.CheckMethodSignature(method) {
			continue
		}

		methodName := method.Name()
		methodType := method.Type().(*types.Signature)

		f.Commentf("Encode%sRequest encode endpoint request struct to gRPC message struct.", methodName)
		f.Func().
			Id(fmt.Sprintf("Encode%sRequest", methodName)).
			Params(jen.Id("req").Qual(epPkg, fmt.Sprintf("%sRequest", methodName))).
			Params(jen.Id(fmt.Sprintf("%sRequest", methodName)), jen.Error()).
			BlockFunc(func(g *jen.Group) {
				g.Id("ret").Op(":=").Op("&").Id(fmt.Sprintf("%sRequest", methodName)).Block()
				for i := 1; i < methodType.Params().Len(); i++ {
					param := methodType.Params().At(i)
					stmt, err := utils.GenCopyVar(param, "ret", "req")
					if err == nil {
						for _, v := range stmt {
							g.Add(v)
						}
					}
				}

				g.Return(jen.Id("ret"), jen.Nil())
			}).Line()
	}

	return f.Render(gf.Writer)
}

func (g GRPCTransportGenerator) generateGoGen(req *driver.GenerateRequest) error {
	gf := req.GenFile("transport/grpc/gen.go")
	gf.P("// This file is generated by jk, DO NOT EDIT.\n")
	gf.P()
	gf.P("package grpc\n")
	gf.P("//go:generate protoc --go-grpc_out=paths=source_relative:. --go_out=paths=source_relative:. rpc.proto\n")
	return nil
}
